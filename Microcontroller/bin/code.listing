
bin/code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .data         00000000  00800100  00800100  00000228  2**0  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001b4  00000000  00000000  00000074  2**1  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  00800100  00800100  00000228  2**0  ALLOC
  3 .stab         000016b0  00000000  00000000  00000228  2**2  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002359  00000000  00000000  000018d8  2**0  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003c31  2**0  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003c44  2**2  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  00003c84  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  00004278  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001d  00000000  00000000  0000481a  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  00004837  2**0  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00800100 l    d  .data	00000000 .data
00000000 l    d  .text	00000000 .text
00800100 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .note.gnu.avr.deviceinfo	00000000 .note.gnu.avr.deviceinfo
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    df *ABS*	00000000 _clear_bss.o
0000007e l       .text	00000000 .do_clear_bss_start
0000007c l       .text	00000000 .do_clear_bss_loop
00000000 l    df *ABS*	00000000 code.cpp
0000003e l       *ABS*	00000000 __SP_H__
0000003d l       *ABS*	00000000 __SP_L__
0000003f l       *ABS*	00000000 __SREG__
00000000 l       *ABS*	00000000 __tmp_reg__
00000001 l       *ABS*	00000000 __zero_reg__
00000000 l    df *ABS*	00000000 main.cpp
0000003e l       *ABS*	00000000 __SP_H__
0000003d l       *ABS*	00000000 __SP_L__
0000003f l       *ABS*	00000000 __SREG__
00000000 l       *ABS*	00000000 __tmp_reg__
00000001 l       *ABS*	00000000 __zero_reg__
00000000 l    df *ABS*	00000000 wiring.c
0000003e l       *ABS*	00000000 __SP_H__
0000003d l       *ABS*	00000000 __SP_L__
0000003f l       *ABS*	00000000 __SREG__
00000000 l       *ABS*	00000000 __tmp_reg__
00000001 l       *ABS*	00000000 __zero_reg__
00800100 l     O .bss	00000001 timer0_fract
00000000 l    df *ABS*	00000000 _exit.o
000001b2 l       .text	00000000 __stop_program
00000000 l    df *ABS*	00000000 
000001b4 l       *ABS*	00000000 __data_load_start
00000088  w      .text	00000000 __vector_22
00800105 g     O .bss	00000004 timer0_overflow_count
00000088  w      .text	00000000 __vector_1
0000ffa0 g       *ABS*	00000000 __DATA_REGION_LENGTH__
00800101 g     O .bss	00000004 timer0_millis
00000068 g       .text	00000000 __trampolines_start
000001b4 g       .text	00000000 _etext
00000088  w      .text	00000000 __vector_24
0000008c g     F .text	00000002 loop
00000088  w      .text	00000000 __vector_12
0000008e  w    F .text	00000002 initVariant
00000088 g       .text	00000000 __bad_interrupt
000001b4 g       *ABS*	00000000 __data_load_end
00000088  w      .text	00000000 __vector_6
00000068 g       .text	00000000 __trampolines_end
00000088  w      .text	00000000 __vector_3
00000088  w      .text	00000000 __vector_23
00000068 g       .text	00000000 __dtors_end
00800109 g       .bss	00000000 __bss_end
00000400 g       *ABS*	00000000 __LOCK_REGION_LENGTH__
00000088  w      .text	00000000 __vector_25
00000088  w      .text	00000000 __vector_11
00000068  w      .text	00000000 __init
00000088  w      .text	00000000 __vector_13
00000088  w      .text	00000000 __vector_17
00000088  w      .text	00000000 __vector_19
00000088  w      .text	00000000 __vector_7
00000074 g       .text	00000010 .hidden __do_clear_bss
00810000 g       .stab	00000000 __eeprom_end
00000000 g       .text	00000000 __vectors
00000000  w      .text	00000000 __vector_default
00000088  w      .text	00000000 __vector_5
00000400 g       *ABS*	00000000 __SIGNATURE_REGION_LENGTH__
0000013a g     F .text	00000076 init
00000068 g       .text	00000000 __ctors_start
00800100 g       .bss	00000000 __bss_start
00000090 g     F .text	00000016 main
00000088  w      .text	00000000 __vector_4
00000000  w      *ABS*	00000000 __heap_end
00000088  w      .text	00000000 __vector_9
00000088  w      .text	00000000 __vector_2
00000400 g       *ABS*	00000000 __USER_SIGNATURE_REGION_LENGTH__
00000088  w      .text	00000000 __vector_21
00000088  w      .text	00000000 __vector_15
0000008a g     F .text	00000002 setup
00000068 g       .text	00000000 __dtors_start
00000068 g       .text	00000000 __ctors_end
000008ff  w      *ABS*	00000000 __stack
00800100 g       .data	00000000 _edata
00800109 g       .stab	00000000 _end
00000088  w      .text	00000000 __vector_8
000001b0  w      .text	00000000 .hidden exit
00010000 g       *ABS*	00000000 __EEPROM_REGION_LENGTH__
000001b0 g       .text	00000000 .hidden _exit
00000088  w      .text	00000000 __vector_14
00000088  w      .text	00000000 __vector_10
000000a6 g     F .text	00000094 __vector_16
00000088  w      .text	00000000 __vector_18
00000400 g       *ABS*	00000000 __FUSE_REGION_LENGTH__
00020000 g       *ABS*	00000000 __TEXT_REGION_LENGTH__
00000088  w      .text	00000000 __vector_20



Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	41 c0       	rjmp	.+130    	; 0x88 <__bad_interrupt>
   6:	00 00       	nop
   8:	3f c0       	rjmp	.+126    	; 0x88 <__bad_interrupt>
   a:	00 00       	nop
   c:	3d c0       	rjmp	.+122    	; 0x88 <__bad_interrupt>
   e:	00 00       	nop
  10:	3b c0       	rjmp	.+118    	; 0x88 <__bad_interrupt>
  12:	00 00       	nop
  14:	39 c0       	rjmp	.+114    	; 0x88 <__bad_interrupt>
  16:	00 00       	nop
  18:	37 c0       	rjmp	.+110    	; 0x88 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	35 c0       	rjmp	.+106    	; 0x88 <__bad_interrupt>
  1e:	00 00       	nop
  20:	33 c0       	rjmp	.+102    	; 0x88 <__bad_interrupt>
  22:	00 00       	nop
  24:	31 c0       	rjmp	.+98     	; 0x88 <__bad_interrupt>
  26:	00 00       	nop
  28:	2f c0       	rjmp	.+94     	; 0x88 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	2d c0       	rjmp	.+90     	; 0x88 <__bad_interrupt>
  2e:	00 00       	nop
  30:	2b c0       	rjmp	.+86     	; 0x88 <__bad_interrupt>
  32:	00 00       	nop
  34:	29 c0       	rjmp	.+82     	; 0x88 <__bad_interrupt>
  36:	00 00       	nop
  38:	27 c0       	rjmp	.+78     	; 0x88 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	25 c0       	rjmp	.+74     	; 0x88 <__bad_interrupt>
  3e:	00 00       	nop
  40:	32 c0       	rjmp	.+100    	; 0xa6 <__vector_16>
  42:	00 00       	nop
  44:	21 c0       	rjmp	.+66     	; 0x88 <__bad_interrupt>
  46:	00 00       	nop
  48:	1f c0       	rjmp	.+62     	; 0x88 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	1d c0       	rjmp	.+58     	; 0x88 <__bad_interrupt>
  4e:	00 00       	nop
  50:	1b c0       	rjmp	.+54     	; 0x88 <__bad_interrupt>
  52:	00 00       	nop
  54:	19 c0       	rjmp	.+50     	; 0x88 <__bad_interrupt>
  56:	00 00       	nop
  58:	17 c0       	rjmp	.+46     	; 0x88 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	15 c0       	rjmp	.+42     	; 0x88 <__bad_interrupt>
  5e:	00 00       	nop
  60:	13 c0       	rjmp	.+38     	; 0x88 <__bad_interrupt>
  62:	00 00       	nop
  64:	11 c0       	rjmp	.+34     	; 0x88 <__bad_interrupt>
	...

00000068 <__ctors_end>:
__trampolines_start():
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
__do_clear_bss():
  74:	21 e0       	ldi	r18, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a9 30       	cpi	r26, 0x09	; 9
  80:	b2 07       	cpc	r27, r18
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
.do_clear_bss_start():
  84:	05 d0       	rcall	.+10     	; 0x90 <main>
  86:	94 c0       	rjmp	.+296    	; 0x1b0 <_exit>

00000088 <__bad_interrupt>:
__vector_22():
  88:	bb cf       	rjmp	.-138    	; 0x0 <__vectors>

0000008a <setup>:
setup():
  8a:	08 95       	ret

0000008c <loop>:
loop():
bin/code.cpp:7
#include <Arduino.h>
void setup() {

}

void loop() {
  8c:	08 95       	ret

0000008e <initVariant>:
  8e:	08 95       	ret

00000090 <main>:
main():
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:35
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
  90:	54 d0       	rcall	.+168    	; 0x13a <init>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:37

	initVariant();
  92:	fd df       	rcall	.-6      	; 0x8e <initVariant>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:43

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
  94:	fa df       	rcall	.-12     	; 0x8a <setup>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:47
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
  96:	c0 e0       	ldi	r28, 0x00	; 0
  98:	d0 e0       	ldi	r29, 0x00	; 0
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:46
		loop();
  9a:	f8 df       	rcall	.-16     	; 0x8c <loop>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/main.cpp:47
		if (serialEventRun) serialEventRun();
  9c:	20 97       	sbiw	r28, 0x00	; 0
  9e:	e9 f3       	breq	.-6      	; 0x9a <main+0xa>
  a0:	0e 94 00 00 	call	0	; 0x0 <__vectors>
  a4:	fa cf       	rjmp	.-12     	; 0x9a <main+0xa>

000000a6 <__vector_16>:
__vector_16():
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	2f 93       	push	r18
  b2:	3f 93       	push	r19
  b4:	8f 93       	push	r24
  b6:	9f 93       	push	r25
  b8:	af 93       	push	r26
  ba:	bf 93       	push	r27
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:50
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
  bc:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <timer0_millis>
  c0:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <timer0_millis+0x1>
  c4:	a0 91 03 01 	lds	r26, 0x0103	; 0x800103 <timer0_millis+0x2>
  c8:	b0 91 04 01 	lds	r27, 0x0104	; 0x800104 <timer0_millis+0x3>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:51
	unsigned char f = timer0_fract;
  cc:	30 91 00 01 	lds	r19, 0x0100	; 0x800100 <_edata>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:54

	m += MILLIS_INC;
	f += FRACT_INC;
  d0:	23 e0       	ldi	r18, 0x03	; 3
  d2:	23 0f       	add	r18, r19
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:55
	if (f >= FRACT_MAX) {
  d4:	2d 37       	cpi	r18, 0x7D	; 125
  d6:	58 f5       	brcc	.+86     	; 0x12e <__vector_16+0x88>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:53
	m += MILLIS_INC;
  d8:	01 96       	adiw	r24, 0x01	; 1
  da:	a1 1d       	adc	r26, r1
  dc:	b1 1d       	adc	r27, r1
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:60
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
  de:	20 93 00 01 	sts	0x0100, r18	; 0x800100 <_edata>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:61
	timer0_millis = m;
  e2:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <timer0_millis>
  e6:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <timer0_millis+0x1>
  ea:	a0 93 03 01 	sts	0x0103, r26	; 0x800103 <timer0_millis+0x2>
  ee:	b0 93 04 01 	sts	0x0104, r27	; 0x800104 <timer0_millis+0x3>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:62
	timer0_overflow_count++;
  f2:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <timer0_overflow_count>
  f6:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <timer0_overflow_count+0x1>
  fa:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <timer0_overflow_count+0x2>
  fe:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <timer0_overflow_count+0x3>
 102:	01 96       	adiw	r24, 0x01	; 1
 104:	a1 1d       	adc	r26, r1
 106:	b1 1d       	adc	r27, r1
 108:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <timer0_overflow_count>
 10c:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <timer0_overflow_count+0x1>
 110:	a0 93 07 01 	sts	0x0107, r26	; 0x800107 <timer0_overflow_count+0x2>
 114:	b0 93 08 01 	sts	0x0108, r27	; 0x800108 <timer0_overflow_count+0x3>
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:63
}
 118:	bf 91       	pop	r27
 11a:	af 91       	pop	r26
 11c:	9f 91       	pop	r25
 11e:	8f 91       	pop	r24
 120:	3f 91       	pop	r19
 122:	2f 91       	pop	r18
 124:	0f 90       	pop	r0
 126:	0f be       	out	0x3f, r0	; 63
 128:	0f 90       	pop	r0
 12a:	1f 90       	pop	r1
 12c:	18 95       	reti
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:56
		f -= FRACT_MAX;
 12e:	26 e8       	ldi	r18, 0x86	; 134
 130:	23 0f       	add	r18, r19
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:57
		m += 1;
 132:	02 96       	adiw	r24, 0x02	; 2
 134:	a1 1d       	adc	r26, r1
 136:	b1 1d       	adc	r27, r1
 138:	d2 cf       	rjmp	.-92     	; 0xde <__vector_16+0x38>

0000013a <init>:
init():
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:245

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 13a:	78 94       	sei
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:251
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 13c:	84 b5       	in	r24, 0x24	; 36
 13e:	82 60       	ori	r24, 0x02	; 2
 140:	84 bd       	out	0x24, r24	; 36
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:252
	sbi(TCCR0A, WGM00);
 142:	84 b5       	in	r24, 0x24	; 36
 144:	81 60       	ori	r24, 0x01	; 1
 146:	84 bd       	out	0x24, r24	; 36
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:265
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 148:	85 b5       	in	r24, 0x25	; 37
 14a:	82 60       	ori	r24, 0x02	; 2
 14c:	85 bd       	out	0x25, r24	; 37
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:266
	sbi(TCCR0B, CS00);
 14e:	85 b5       	in	r24, 0x25	; 37
 150:	81 60       	ori	r24, 0x01	; 1
 152:	85 bd       	out	0x25, r24	; 37
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:279

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 154:	ee e6       	ldi	r30, 0x6E	; 110
 156:	f0 e0       	ldi	r31, 0x00	; 0
 158:	80 81       	ld	r24, Z
 15a:	81 60       	ori	r24, 0x01	; 1
 15c:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:290
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 15e:	e1 e8       	ldi	r30, 0x81	; 129
 160:	f0 e0       	ldi	r31, 0x00	; 0
 162:	10 82       	st	Z, r1
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:293

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 164:	80 81       	ld	r24, Z
 166:	82 60       	ori	r24, 0x02	; 2
 168:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:295
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 16a:	80 81       	ld	r24, Z
 16c:	81 60       	ori	r24, 0x01	; 1
 16e:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:305
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 170:	e0 e8       	ldi	r30, 0x80	; 128
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	80 81       	ld	r24, Z
 176:	81 60       	ori	r24, 0x01	; 1
 178:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:312

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 17a:	e1 eb       	ldi	r30, 0xB1	; 177
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	80 81       	ld	r24, Z
 180:	84 60       	ori	r24, 0x04	; 4
 182:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:321

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 184:	e0 eb       	ldi	r30, 0xB0	; 176
 186:	f0 e0       	ldi	r31, 0x00	; 0
 188:	80 81       	ld	r24, Z
 18a:	81 60       	ori	r24, 0x01	; 1
 18c:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:356
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 18e:	ea e7       	ldi	r30, 0x7A	; 122
 190:	f0 e0       	ldi	r31, 0x00	; 0
 192:	80 81       	ld	r24, Z
 194:	84 60       	ori	r24, 0x04	; 4
 196:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:357
		sbi(ADCSRA, ADPS1);
 198:	80 81       	ld	r24, Z
 19a:	82 60       	ori	r24, 0x02	; 2
 19c:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:358
		sbi(ADCSRA, ADPS0);
 19e:	80 81       	ld	r24, Z
 1a0:	81 60       	ori	r24, 0x01	; 1
 1a2:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:381
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 1a4:	80 81       	ld	r24, Z
 1a6:	80 68       	ori	r24, 0x80	; 128
 1a8:	80 83       	st	Z, r24
/usr/share/arduino/hardware/archlinux-arduino/avr/cores/arduino/wiring.c:390
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 1aa:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 1ae:	08 95       	ret

000001b0 <_exit>:
 1b0:	f8 94       	cli

000001b2 <__stop_program>:
 1b2:	ff cf       	rjmp	.-2      	; 0x1b2 <__stop_program>
